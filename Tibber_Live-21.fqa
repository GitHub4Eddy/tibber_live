{"name":"Tibber Live","type":"com.fibaro.powerMeter","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_1473"},"sections":{"items":[{"components":[{"name":"label","style":{"weight":"1.2"},"text":"Label","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_1473"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"debugLevel","type":"string","value":"1"},{"name":"reconnect","type":"string","value":"10"},{"name":"timeout","type":"string","value":"300"},{"name":"token","type":"string","value":"5K4MVS-OjfWhK_4yrjOlFe1F6kJXPVf7eQYggo8ebAE"},{"name":"homeId","type":"string","value":"96a14971-525a-4420-aae9-e5aedaa129ff"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- QUICKAPP TIBBER LIVE\n\n-- This QuickApp gets your energy consumption and production data from Tibber Live. \n-- This QuickApp can be used in combination with the Tibber Monitor to get the Tibber Prices. \n-- Based on the Fibaro WebSockets/GraphQL demo by Peter Gebruers \n\n-- If you use Tibber for your Energy Panel, you can use this Tibber Live QuickApp for your energy consumption and production combined with the Tibber Monitor QuickApp to provide the Energy Panel with the hourly prices. \n\n\n-- Available information: \n-- power (Consumption at the moment (Watt))\n-- maxPower (Peak consumption since midnight (Watt))\n-- powerProduction (Net production (A-) at the moment (Watt))\n-- maxPowerProduction (Max net production since midnight (Watt))\n-- accumulatedConsumption (kWh consumed since midnight)\n-- accumulatedProduction (net kWh produced since midnight)\n-- accumulatedCost (Accumulated cost since midnight; requires active Tibber power deal)\n-- currency (Currency of displayed cost; requires active Tibber power deal)\n-- lastMeterConsumption (Last meter active import register state (kWh))\n-- lastMeterProduction (Last meter active export register state (kWh))\n-- voltagePhase1 (Voltage on phase 1) *\n-- voltagePhase2 (Voltage on phase 2) *\n-- voltagePhase3 (Voltage on phase 3) *\n-- currentL1 (Current on L1) *\n-- currentL2 (Current on L2) *\n-- currentL3 (Current on L3) *\n-- accumulatedConsumptionLastHour (kWh consumed since since last hour shift)\n-- accumulatedProductionLastHour (net kWh produced since last hour shift)\n-- accumulatedReward (Accumulated reward since midnight; requires active Tibber power deal)\n-- minPower (Min consumption since midnight (Watt))\n-- averagePower (Average consumption since midnight (Watt))\n-- powerReactive (Reactive consumption (Q+) at the moment (kVAr)) *\n-- powerProductionReactive (Net reactive production (Q-) at the moment (kVAr)) *\n-- minPowerProduction (Min net production since midnight (Watt))\n-- maxPowerProduction (Max net production since midnight (Watt))\n-- powerFactor (Power factor (active power / apparent power)) *\n-- signalStrength (Device signal strength (Pulse - dB; Watty - percent)) *\n-- timestamp (Timestamp when usage occurred)\n\n-- * on Kaifa and Aidon meters the value is not part of every HAN data frame therefore the value is \"null\" at timestamps with second value other than 0, 10, 20, 30, 40, 50. There can be other deviations based on concrete meter firmware.) In this QuickApp \"null\" values are replaced by their previous values. \n\n\n-- Main device with positive or negative actual power consumption (with timestamp in the log text)\n\n-- Child devices are available for:\n-- power (Actual consumption with maxPower in log text)\n-- powerProduction (Actual production with maxPowerProduction in log text)\n-- accumulatedConsumption (Todays consumption, also the child device for the Energy Panel)\n-- accumulatedProduction (Todays production)\n-- accumulatedCost (Todays cost)\n-- accumulatedConsumptionLastHour (Consumed since since last hour shift)\n-- accumulatedProductionLastHour (Produced since last hour shift)\n-- lastMeterConsumption (Total consumption)\n-- lastMeterProduction (Total production)\n-- voltagePhase1\n-- voltagePhase2\n-- voltagePhase3\n-- currentL1\n-- currentL2\n-- currentL3\n\n\n-- To communicate with the API you need to acquire a OAuth access token and pass this along with every request passed to the server.\n-- A Personal Access Token give you access to your data and your data only. \n-- This is ideal for DIY people that want to leverage the Tibber platform to extend the smartness of their home. \n-- Such a token can be acquired here: https://developer.tibber.com\n\n-- When creating your access token or OAuth client you’ll be asked which scopes you want the access token to be associated with. \n-- These scopes tells the API which data and operations the client is allowed to perform on the user’s behalf. \n-- The scopes your app requires depend on the type of data it is trying to request. \n-- If you for example need access to user information you add the USER scope. \n-- If information about the user's homes is needed you add the appropriate HOME scopes.\n-- If you have more than one home in your subscription, you need to fill in your home number the change between your homes. \n\n-- If the Tibber server disconnects the webSocket, the QuickApp wil do a re-connect for the amount in the QuickApp variable reconnect. \n-- If the re-connect fails for that amount, there will be a timeout for the seconds in the QuickApp variable timeout. \n\n-- Use this QuickApp at your own risk. You are responsible for ensuring that the information provided via this QuickApp do not contain errors. \n-- Tibber is a registered trademark being the property of TIBBER. TIBBER reserves all rights to the registered trademarks.\n-- Information which is published on TIBBER’s websites belongs to TIBBER or is used with the permission of the rights holder. \n-- Making of copies, presentations, distribution, display or any other transfer of the information on the website to the public is, except for strictly private use, prohibited unless done with the consent of TIBBER. \n-- Published material on dedicated TIBBER press websites, intended for public use, is exempt from the consent requirement.\n-- Also see: https://tibber.com/en/legal-notice\n\n-- Guide Communicating with the Tibber API: https://developer.tibber.com/docs/guides/calling-api\n-- Tibber API Explorer: https://developer.tibber.com/explorer\n-- Fibaro webSocket manual: https://manuals.fibaro.com/knowledge-base-browse/hc3-quick-apps-websocket-client/\n-- Fibaro Forum Headers in webSocket: https://forum.fibaro.com/topic/60307-added-support-for-headers-in-websocket-connections-any-documentation\n-- WebSocket++ Documentation: https://docs.websocketpp.org\n-- GraphQL query language: https://spec.graphql.org/June2018/#sec-Language\n\n\n-- TODO (maybe): \n-- Wrap json.decode in pcall (?)\n-- Change global variables to local variables (?)\n-- Add the “Extra Cost” from the Tibber Monitor QA to the “Todays Cost” in Tibber Live\n-- Add extra timeout in reconnect routine (2x)\n-- Show connection status in labels\n\n\n-- Version 2.1 15th October 2022\n-- Child devices are now updated every (whole) minute to reduce CPU load\n-- Replaced zero values for Voltage L1 L2 L3 with the previous value\n\n\n-- Version 2.0 (5th August 2022)\n-- Added two child devices, Hourly Consumption and Hourly Production\n-- Added re-connect routine to handleError. If an Tibber error occurs, the QuickApp will try to re-connect. Thanks @JcBorgs for testing. \n-- Improved routine to handle Tibber null value. Thanks @Darquan for testing. \n-- Changed labels a bit to save some space\n-- Changed \"volt\" and \"amp\" text in the labels\n-- Changed kWh device types from com.fibaro.electricMeter to com.fibaro.energyMeter\n\n-- Version 1.0 (19th June 2022)\n-- Initial webSocket version Tibber Live\n-- Thanks @JcBorgs for testing all beta versions and great suggestion to improve the quickapp\n-- Based on the Fibaro WebSockets/GraphQL demo by Peter Gebruers \n\n-- Variables (mandatory and created automatically): \n-- token = Authorization token (see the Tibber website: https://developer.tibber.com)\n-- homeId = Tibber Home ID (see the Tibber website: https://developer.tibber.com)\n-- reconnect = Amount of re-connects after disconnect from Tibber server (default = 10)\n-- timeout = Pause after maximum amount of re-connects (default = 300 seconds)\n-- debugLevel = Number (1=some, 2=few, 3=all, 4=Offline Simulation Mode, 5=Live Test Mode) (default = 1)\n\n-- Fibaro Firmware minimal version 5.111.48 (beta)\n\n-- No editing of this code is needed \n\n\n-- Child Devices\n\nclass 'power'(QuickAppChild)\nfunction power:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction power:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.power)))\n  self:updateProperty(\"power\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.power)))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", \"Max \" ..data.payload.data.liveMeasurement.maxPower ..\" Watt\")\nend\n\nclass 'powerProduction'(QuickAppChild)\nfunction powerProduction:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction powerProduction:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.powerProduction)))\n  self:updateProperty(\"power\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.powerProduction)))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", \"Max \" ..data.payload.data.liveMeasurement.maxPowerProduction ..\" Watt\")\nend\n\nclass 'accumulatedConsumption'(QuickAppChild)\nfunction accumulatedConsumption:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"consumption\" then \n    self:updateProperty(\"rateType\", \"consumption\")\n    self:warning(\"Changed rateType interface of Todays Consumption child device (\" ..self.id ..\") to consumption\")\n  end\nend\nfunction accumulatedConsumption:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedConsumption)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'accumulatedProduction'(QuickAppChild)\nfunction accumulatedProduction:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n    self:warning(\"Changed rateType interface of Todays Production child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction accumulatedProduction:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedProduction)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'accumulatedCost'(QuickAppChild)\nfunction accumulatedCost:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction accumulatedCost:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedCost)))\n  self:updateProperty(\"unit\", data.payload.data.liveMeasurement.currency)\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'accumulatedConsumptionLastHour'(QuickAppChild)\nfunction accumulatedConsumptionLastHour:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"consumption\" then \n    self:updateProperty(\"rateType\", \"consumption\")\n    self:warning(\"Changed rateType interface of Last Hour Consumption child device (\" ..self.id ..\") to consumption\")\n  end\nend\nfunction accumulatedConsumptionLastHour:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedConsumptionLastHour)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'accumulatedProductionLastHour'(QuickAppChild)\nfunction accumulatedProductionLastHour:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n    self:warning(\"Changed rateType interface of Last Hour Production child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction accumulatedProductionLastHour:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedProductionLastHour)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'lastMeterConsumption'(QuickAppChild)\nfunction lastMeterConsumption:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"consumption\" then \n    self:updateProperty(\"rateType\", \"consumption\")\n    self:warning(\"Changed rateType interface of Total Consumption child device (\" ..self.id ..\") to consumption\")\n  end\nend\nfunction lastMeterConsumption:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.lastMeterConsumption)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'lastMeterProduction'(QuickAppChild)\nfunction lastMeterProduction:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n    self:warning(\"Changed rateType interface of Total Production child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction lastMeterProduction:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.lastMeterProduction)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'voltagePhase1'(QuickAppChild)\nfunction voltagePhase1:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction voltagePhase1:updateValue(data) \n  prevdata.voltagePhase1 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.voltagePhase1)))\n  self:updateProperty(\"unit\", \"Volt\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'voltagePhase2'(QuickAppChild)\nfunction voltagePhase2:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction voltagePhase2:updateValue(data) \n  prevdata.voltagePhase2 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.voltagePhase2)))\n  self:updateProperty(\"unit\", \"Volt\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'voltagePhase3'(QuickAppChild)\nfunction voltagePhase3:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction voltagePhase3:updateValue(data) \n  prevdata.voltagePhase3 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.voltagePhase3)))\n  self:updateProperty(\"unit\", \"Volt\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'currentL1'(QuickAppChild)\nfunction currentL1:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction currentL1:updateValue(data) \n  prevdata.currentL1 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.currentL1)))\n  self:updateProperty(\"unit\", \"Amp\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'currentL2'(QuickAppChild)\nfunction currentL2:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction currentL2:updateValue(data) \n  prevdata.currentL2 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.currentL2)))\n  self:updateProperty(\"unit\", \"Amp\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'currentL3'(QuickAppChild)\nfunction currentL3:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction currentL3:updateValue(data) \n  prevdata.currentL2 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.currentL3)))\n  self:updateProperty(\"unit\", \"Amp\")\n  self:updateProperty(\"log\", \"\")\nend\n\n\nlocal function getChildVariable(child,varName)\n  for _,v in ipairs(child.properties.quickAppVariables or {}) do\n    if v.name==varName then return v.value end\n  end\n  return \"\"\nend\n\n\n-- QuickApp functions\n\n\nfunction QuickApp:updateChildDevices() -- Update Child Devices\n  for id,child in pairs(self.childDevices) do \n    child:updateValue(data) \n  end\nend\n\n\nfunction QuickApp:logging(level,text) -- Logging function for debug\n  if tonumber(debugLevel) >= tonumber(level) then \n      self:debug(text)\n  end\nend\n\n\nfunction QuickApp:buttonEvent() -- Button event\n  self:logging(3, \"QuickApp:buttonEvent\")\n    self:updateButtonLabel(\"Please wait...\")\n  --self:...() -- Do something\n  fibaro.setTimeout(2000, function()\n    self:updateButtonLabel(\"Refresh\")\n  end)\nend\n\n\nfunction QuickApp:updateButtonLabel(text) -- Update the label of the button \n  self:logging(3,\"updateButtonLabel\")\n  self:updateView(\"button\", \"text\", text)\nend\n\n\nfunction QuickApp:updateProperties() -- Update the properties\n  self:logging(3,\"updateProperties\")\n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.power-data.payload.data.liveMeasurement.powerProduction)))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", data.payload.data.liveMeasurement.timestamp)\nend\n\n\nfunction QuickApp:updateLabels() -- Update the labels\n  self:logging(3,\"updateLabels\")\n\n  local labelText = \"\"\n  if debugLevel == 4 then\n    labelText = labelText ..\"SIMULATION MODE\" ..\"\\n\\n\"\n  end\n\n  labelText = labelText ..\"Consumption: \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.power) ..\" Watt\" ..\"\\n\"\n  labelText = labelText ..\"Production: \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.powerProduction) ..\" Watt\" ..\"\\n\\n\"\n  \n  labelText = labelText ..\"Hourly Consumption: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedConsumptionLastHour) ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..\"Hourly Production: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedProductionLastHour) ..\" kWh\" ..\"\\n\\n\"\n\n  labelText = labelText ..\"Todays Consumption:\" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedConsumption) ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..\"Min: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.minPower) ..\" Max: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.maxPower) ..\" Av: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.averagePower) ..\" Watt\" ..\"\\n\\n\"\n  \n  labelText = labelText ..\"Todays Production: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedProduction) ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..\"Min: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.minPowerProduction) ..\" Max: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.maxPowerProduction)..\" Watt\" ..\"\\n\\n\"\n  \n  labelText = labelText ..\"Todays Cost: \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.accumulatedCost) ..\" \" ..data.payload.data.liveMeasurement.currency ..\"\\n\" \n  labelText = labelText ..\"Reward: \" ..string.format(\"%.2f\",tonumber(data.payload.data.liveMeasurement.accumulatedReward)) ..\" \" ..data.payload.data.liveMeasurement.currency ..\"\\n\\n\" \n\n  labelText = labelText ..\"Totals:\" ..\"\\n\" \n  labelText = labelText ..\"Consumption: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.lastMeterConsumption) ..\" kWh\" ..\"\\n\" \n  labelText = labelText ..\"Production: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.lastMeterProduction) ..\" kWh\" ..\"\\n\\n\" \n  \n  labelText = labelText ..\"Voltage:\" ..\"\\n\"\n  labelText = labelText ..\"L1: \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.voltagePhase1) ..\" - L2: \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.voltagePhase2) ..\" - L3: \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.voltagePhase3) ..\" Volt \" ..\"\\n\\n\"\n  \n  labelText = labelText ..\"Ampere:\" ..\"\\n\"\n  labelText = labelText ..\"L1: \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.currentL1) ..\" - L2: \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.currentL2) ..\" - L3: \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.currentL3) ..\" Amp \" ..\"\\n\\n\"\n  \n  labelText = labelText ..\"Reactive Consumption: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.powerReactive) ..\" kVAr\" ..\"\\n\"\n  labelText = labelText ..\"Reactive Production: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.powerProductionReactive) ..\" kVAr\" ..\"\\n\"\n  labelText = labelText ..\"Power Factor: \" ..string.format(\"%.3f\",data.payload.data.liveMeasurement.powerFactor) ..\" \" ..\"\\n\"\n  labelText = labelText ..\"Signal strength: \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.signalStrength) \n  if tonumber(data.payload.data.liveMeasurement.signalStrength) >= 0 then\n    labelText = labelText ..\"%\" ..\"\\n\"\n  else\n    labelText = labelText ..\" dB\" ..\"\\n\"\n  end\n  labelText = labelText ..\"Timestamp: \" ..data.payload.data.liveMeasurement.timestamp ..\"\\n\"\n\n  self:updateView(\"label\", \"text\", labelText)\n  self:logging(2,\"Label: \" ..labelText)\nend\n\n\nfunction QuickApp:getValues() -- Get the values from json file \n  self:logging(3,\"getValues\")\n  local pattern = \"(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+).(%d+)+(%d+):(%d+)\" --2021-12-23T17:00:00.000+01:00\n  local runyear, runmonth, runday, runhour, runminute, runseconds = data.payload.data.liveMeasurement.timestamp:match(pattern)\n  local convertedTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})\n  data.payload.data.liveMeasurement.timestamp = os.date(\"%d-%m-%Y %H:%M:%S\", convertedTimestamp)\n  \n  self:logging(2,\"data: \" ..json.encode(data))\n  data = json.encode(data):gsub(\"null\", '\"null\"') -- Clean up the response by replacing null with \"null\"\n  data = json.decode(data) \n\n  -- Check for null values and replace them with previous values\n  if data.payload.data.liveMeasurement.voltagePhase1 == \"null\" or data.payload.data.liveMeasurement.voltagePhase1 == nil or data.payload.data.liveMeasurement.voltagePhase1 == 0 then -- Also replace zeor values for Voltage\n    self:logging(3,\"Replaced voltagePhase1 \" ..data.payload.data.liveMeasurement.voltagePhase1 ..\" with: \" ..prevdata.voltagePhase1)\n    data.payload.data.liveMeasurement.voltagePhase1 = tonumber(prevdata.voltagePhase1)\n  else\n    prevdata.voltagePhase1 = data.payload.data.liveMeasurement.voltagePhase1 \n  end\n  if data.payload.data.liveMeasurement.voltagePhase2 == \"null\" or data.payload.data.liveMeasurement.voltagePhase2 == nil or data.payload.data.liveMeasurement.voltagePhase2 == 0 then -- Also replace zeor values for Voltage\n    self:logging(3,\"Replaced voltagePhase2 \" ..data.payload.data.liveMeasurement.voltagePhase2 ..\" with: \" ..prevdata.voltagePhase2)\n    data.payload.data.liveMeasurement.voltagePhase2 = tonumber(prevdata.voltagePhase2)\n  else\n    prevdata.voltagePhase2 = data.payload.data.liveMeasurement.voltagePhase2\n  end\n  if data.payload.data.liveMeasurement.voltagePhase3 == \"null\" or data.payload.data.liveMeasurement.voltagePhase3 == nil or data.payload.data.liveMeasurement.voltagePhase3 == 0 then -- Also replace zeor values for Voltage\n    self:logging(3,\"Replaced voltagePhase3 \" ..data.payload.data.liveMeasurement.voltagePhase3 ..\" with: \" ..prevdata.voltagePhase3)\n    data.payload.data.liveMeasurement.voltagePhase3 = tonumber(prevdata.voltagePhase3)\n  else\n    prevdata.voltagePhase3 = data.payload.data.liveMeasurement.voltagePhase3\n  end\n  \n  if data.payload.data.liveMeasurement.currentL1 == \"null\" or data.payload.data.liveMeasurement.currentL1 == nil then\n    self:logging(3,\"Replaced currentL1 \" ..data.payload.data.liveMeasurement.currentL1 ..\" with: \" ..prevdata.currentL1)\n    data.payload.data.liveMeasurement.currentL1 = tonumber(prevdata.currentL1)\n  else\n    prevdata.currentL1 = data.payload.data.liveMeasurement.currentL1\n  end\n  if data.payload.data.liveMeasurement.currentL2 == \"null\" or data.payload.data.liveMeasurement.currentL2 == nil then\n    self:logging(3,\"Replaced currentL2 \" ..data.payload.data.liveMeasurement.currentL2 ..\" with: \" ..prevdata.currentL2)\n    data.payload.data.liveMeasurement.currentL2 = tonumber(prevdata.currentL2)\n  else\n    prevdata.currentL2 = data.payload.data.liveMeasurement.currentL2\n  end\n  if data.payload.data.liveMeasurement.currentL3 == \"null\" or data.payload.data.liveMeasurement.currentL3 == nil then\n    self:logging(3,\"Replaced currentL3 \" ..data.payload.data.liveMeasurement.currentL3 ..\" with: \" ..prevdata.currentL3)\n    data.payload.data.liveMeasurement.currentL3 = tonumber(prevdata.currentL3)\n  else\n    prevdata.currentL3 = data.payload.data.liveMeasurement.currentL3\n  end\n  \n  if data.payload.data.liveMeasurement.powerFactor == \"null\" or data.payload.data.liveMeasurement.powerFactor == nil then\n    self:logging(3,\"Replaced powerFactor \" ..data.payload.data.liveMeasurement.powerFactor ..\" with: \" ..prevdata.powerFactor)\n    data.payload.data.liveMeasurement.powerFactor = tonumber(prevdata.powerFactor)\n  else\n    prevdata.powerFactor = data.payload.data.liveMeasurement.powerFactor \n  end\n  if data.payload.data.liveMeasurement.powerReactive == \"null\" or data.payload.data.liveMeasurement.powerReactive == nil then\n    self:logging(3,\"Replaced powerReactive \" ..data.payload.data.liveMeasurement.powerReactive ..\" with: \" ..prevdata.powerReactive)\n    data.payload.data.liveMeasurement.powerReactive = tonumber(prevdata.powerReactive)\n  else\n    prevdata.powerReactive = data.payload.data.liveMeasurement.powerReactive\n  end\n  if data.payload.data.liveMeasurement.powerProductionReactive == \"null\" or data.payload.data.liveMeasurement.powerProductionReactive == nil then\n    self:logging(3,\"Replaced powerProductionReactive \" ..data.payload.data.liveMeasurement.powerProductionReactive ..\" with: \" ..prevdata.powerProductionReactive)\n    data.payload.data.liveMeasurement.powerProductionReactive = tonumber(prevdata.powerProductionReactive)\n  else\n    prevdata.powerProductionReactive = data.payload.data.liveMeasurement.powerProductionReactive\n  end\n  if data.payload.data.liveMeasurement.signalStrength == \"null\" or data.payload.data.liveMeasurement.signalStrength == nil then\n    self:logging(3,\"Replaced signalStrength \" ..data.payload.data.liveMeasurement.signalStrength ..\" with: \" ..prevdata.signalStrength)\n    data.payload.data.liveMeasurement.signalStrength = tonumber(prevdata.signalStrength)\n  else\n    prevdata.signalStrength = data.payload.data.liveMeasurement.signalStrength\n  end\n  \n  if data.payload.data.liveMeasurement.accumulatedReward == \"null\" or data.payload.data.liveMeasurement.accumulatedReward == nil then\n    self:logging(3,\"Replaced accumulatedReward \" ..data.payload.data.liveMeasurement.accumulatedReward ..\" with: \" ..prevdata.accumulatedReward)\n    data.payload.data.liveMeasurement.accumulatedReward = tonumber(prevdata.accumulatedReward)\n  else\n    prevdata.accumulatedReward = data.payload.data.liveMeasurement.accumulatedReward\n  end\n  if data.payload.data.liveMeasurement.accumulatedCost == \"null\" or data.payload.data.liveMeasurement.accumulatedCost == nil then\n    self:logging(3,\"Replaced accumulatedCost \" ..data.payload.data.liveMeasurement.accumulatedCost ..\" with: \" ..prevdata.accumulatedCost)\n    data.payload.data.liveMeasurement.accumulatedCost = tonumber(prevdata.accumulatedCost)\n  else\n    prevdata.accumulatedCost = data.payload.data.liveMeasurement.accumulatedCost\n  end\n  if data.payload.data.liveMeasurement.currency == \"null\" or data.payload.data.liveMeasurement.currency == nil then\n    self:logging(3,\"Replaced currency \" ..data.payload.data.liveMeasurement.currency ..\" with: \" ..prevdata.currency)\n    data.payload.data.liveMeasurement.currency = prevdata.currency\n  else\n    prevdata.currency = data.payload.data.liveMeasurement.currency\n  end\n  data = json.encode(data):gsub(\"null\", 0) -- Clean up the response by replacing null with 0\n  data = json.decode(data) \n\n  self:logging(2,\"data (without null): \" ..json.encode(data))\nend\n\n\nfunction QuickApp:handleError(error) -- The event is emitted when an error occures\n  self:logging(3,\"handleError\")\n  self:error(\"WebSocket error: \", error)\n  if reconnect > 0 then -- re-connect n times\n    self:logging(3,\"Trying to reconnect ... (\" ..tonumber(reconnect) ..\")\")\n    self:getData()\n    reconnect = reconnect - 1 \n  else -- Never disconnect, retry to re-connect after n seconds\n    reconnect = tonumber(self:getVariable(\"reconnect\"))\n    self:logging(3,\"SetTimeout for re-connect at \" ..timeout ..\" seconds\")\n    fibaro.setTimeout(timeout*1000, function() \n      self:getData()\n    end)\n  end\nend\n\n\nfunction QuickApp:handleDisconnected() -- The event is emitted when either the client or the server closes the socket\n  self:logging(3,\"handleDisconnected\")\n  if reconnect > 0 then -- re-connect n times\n    self:logging(3,\"Trying to reconnect ... (\" ..tonumber(reconnect) ..\")\")\n    self:getData()\n    reconnect = reconnect - 1 \n  else -- Never disconnect, retry to re-connect after n seconds\n    reconnect = tonumber(self:getVariable(\"reconnect\"))\n    self:logging(3,\"SetTimeout for re-connect at \" ..timeout ..\" seconds\")\n    fibaro.setTimeout(timeout*1000, function() \n      self:getData()\n    end)\n  end\nend\n\n\nfunction QuickApp:handleDataReceived(resp) -- The event is emitted when any data is received by the socket\n  self:logging(3,\"handleDataReceived\")\n  data = json.decode(resp) -- TODO: json decode should be wrapped in pcall and error handled?\n\n  if data.type == \"connection_ack\" then -- The initial connection is there, please send the query body\n    self:logging(3,\"Got connection_ack, making and sending query\")\n    self:logging(3,\"graphql_query_body: \" ..graphql_query_body)\n    self.sock:send(graphql_query_body)\n  elseif data.type == \"data\" then -- Tibber Live responded with data, let's see what it is\n    reconnect = tonumber(self:getVariable(\"reconnect\")) -- Reset reconnect to is initial value\n    self:getValues()\n    self:updateLabels()\n    self:updateProperties()\n    \n    if os.date(\"%S\") == \"00\" then -- To reduce CPU load only update Child Devices every whole minute\n      self:logging(3,\"updateChildDevices\")\n      self:updateChildDevices() \n    end\n    \n  else -- Something else is going on \n    self:logging(2,\"Data not handled in handleDataReceived: \"..data.type)\n  end\nend\n\n\nfunction QuickApp:handleConnected()\n  self:logging(3,\"handleConnected\")\n  self.sock:send('{\"type\": \"connection_init\", \"payload\": {}}') -- Only initialize the connection \nend\n\n\nfunction QuickApp:simData() -- Offline Simulation Tibber Live\n  self:logging(3,\"simData\")\n  local resp = '{\"payload\": {\"data\": {\"liveMeasurement\": {\"timestamp\": \"2022-06-16T16:43:20.000+02:00\",\"accumulatedCost\": 1.666866,\"accumulatedReward\": 0.485687,\"accumulatedProduction\": 3.793511,\"accumulatedConsumption\": 11.393055,\"accumulatedProductionLastHour\": 0.056511,\"accumulatedConsumptionLastHour\": 0.252055,\"currentL1\": 1.064,\"currentL2\": 1.159,\"currentL3\": 1.089,\"powerFactor\": 0.919,\"powerReactive\": 17,\"powerProduction\": 176,\"power\": 600,\"voltagePhase1\": 238.9,\"voltagePhase2\": 239,\"voltagePhase3\": 239.2,\"signalStrength\": -48,\"powerProductionReactive\": 508,\"lastMeterProduction\": 3579.144,\"lastMeterConsumption\": 88094.695,\"minPowerProduction\": 0,\"maxPowerProduction\": 5600,\"minPower\": 0,\"averagePower\": 681.3,\"maxPower\": 6665,\"currency\": \"NOK\"}}}}'\n  \n  --status,data = pcall(json.decode,resp)\n  --if not status then \n  --  self:error(data)\n  --end\n  \n  data = json.decode(resp) -- Decode the json string from api to lua-table \n\n  self:getValues()\n  self:updateLabels()\n  self:updateProperties()\n  self:updateChildDevices() \n  \n  local interval = 10\n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout(interval*1000, function() \n     self:simData()\n  end)\nend\n\n\nfunction QuickApp:getData()\n  self:logging(3,\"getData\")\n  self.sock = net.WebSocketClientTls()\n  self.sock:addEventListener(\"connected\", function() self:handleConnected() end)\n  self.sock:addEventListener(\"disconnected\", function() self:handleDisconnected() end)\n  self.sock:addEventListener(\"error\", function(error) self:handleError(error) end)\n  self.sock:addEventListener(\"dataReceived\", function(data) self:handleDataReceived(data) end)\n\n  self:logging(3,\"Connect: \" ..url ..\" \" ..json.encode(headers))\n  self.sock:connect(url, headers)\nend\n\n\nfunction QuickApp:createVariables() -- Create all Variables \n  url = \"wss://api.tibber.com/v1-beta/gql/subscriptions\" -- Tibber Live webSocket URL\n  data = {} -- Table for Tibber response\n  prevdata = {} -- Table for previous values to replace null values\n  prevdata.voltagePhase1 = 0\n  prevdata.voltagePhase2 = 0\n  prevdata.voltagePhase3 = 0\n  prevdata.currentL1 = 0\n  prevdata.currentL2 = 0\n  prevdata.currentL3 = 0\n  prevdata.powerFactor = 0\n  prevdata.powerReactive = 0\n  prevdata.signalStrength = 0\n  prevdata.powerProductionReactive = 0\n  prevdata.accumulatedReward = 0\n  prevdata.accumulatedCost = 0\n  prevdata.accumulatedConsumption = 0 -- Extra for calculation current price (experimental feature)\n  prevdata.accumulatedProduction = 0 -- Extra for calculation current price (experimental feature)\n  prevdata.currency = \"EUR\"\n  \n  headers = {} -- Headers for authorization and protocol\n  headers[\"Authorization\"] = token\n  headers[\"Sec-WebSocket-Protocol\"] = \"graphql-ws\"\n  \n  local graphql_query = {} -- Query for Subscription Live Measurement\n  graphql_query.type = 'start'\n  graphql_query.id = \"1\"\n  graphql_query.payload = {}\n  graphql_query.payload.query = 'subscription{liveMeasurement(homeId:\"' ..homeId ..'\"){power maxPower powerProduction maxPowerProduction accumulatedConsumption accumulatedProduction accumulatedCost currency lastMeterConsumption lastMeterProduction voltagePhase1 voltagePhase2 voltagePhase3 currentL1 currentL2 currentL3 accumulatedConsumptionLastHour accumulatedProductionLastHour accumulatedReward minPower averagePower powerReactive powerProductionReactive minPowerProduction powerFactor signalStrength timestamp}}'\n  graphql_query_body = json.encode(graphql_query)\nend\n\n\nfunction QuickApp:getQuickAppVariables() -- Check existence of the mandatory variables, if not, create them with default values\n  token = self:getVariable(\"token\")\n  homeId = self:getVariable(\"homeId\")\n  reconnect = tonumber(self:getVariable(\"reconnect\"))\n  timeout = tonumber(self:getVariable(\"timeout\"))\n  debugLevel = tonumber(self:getVariable(\"debugLevel\"))\n\n  if debugLevel == \"\" or debugLevel == nil then\n    debugLevel = \"1\" -- Default debug level\n    self:setVariable(\"debugLevel\",debugLevel)\n    self:trace(\"Added QuickApp variable debugLevel\")\n    debugLevel = tonumber(debugLevel)\n  end\n  if token == \"\" or token == nil or token == \"0\" then\n    token = \"476c477d8a039529478ebd690d35ddd80e3308ffc49b59c65b142321aee963a4\" -- This token is just an demo/test example, only for demo/test purposes\n    self:setVariable(\"token\",token)\n    self:trace(\"Added QuickApp variable with DEMO (!) token. Get your token from the Tibber website and parse it to the quickapp variable\")\n    debugLevel = 4 -- Offline Simulation Mode due to DEMO token\n    self:warning(\"Switched to Offline Simulation Mode\")\n  end\n  if homeId == \"\" or homeId == nil or homeId == \"0\" then\n    homeId = \"cc83e83e-8cbf-4595-9bf7-c3cf192f7d9c\"-- This Home ID is just an demo/test example, only for demo/test purposes\n    self:setVariable(\"homeId\",homeId)\n    self:trace(\"Added QuickApp variable with DEMO (!) Home ID. Get your Home ID from the Tibber website and parse it to the quickapp variable\")\n    debugLevel = 4 -- Offline Simulation Mode due to DEMO Home ID\n    self:warning(\"Switched to Offline Simulation Mode\")\n  end\n  if reconnect == \"\" or reconnect == nil then\n    reconnect = \"10\" -- Default amount of re-connects \n    self:setVariable(\"reconnect\",reconnect)\n    self:trace(\"Added QuickApp variable reconnect\")\n    reconnect = tonumber(reconnect)\n  end\n  if timeout == \"\" or timeout == nil or timeout == 0 then\n    timeout = \"300\" -- Default timeout after maximum re-connects in seconds\n    self:setVariable(\"timeout\",timeout)\n    self:trace(\"Added QuickApp variable timeout\")\n    timeout = tonumber(timeout)\n  end\n  if debuglevel == 5 then -- Live Test Mode\n    token = \"476c477d8a039529478ebd690d35ddd80e3308ffc49b59c65b142321aee963a4\"\n    homeId = \"cc83e83e-8cbf-4595-9bf7-c3cf192f7d9c\"\n    self:warning(\"DebugLevel = 5 (Live Test mode): Changed Tibber Token and Home ID to Tibber TEST values\")\n  end\nend\n\n\nfunction QuickApp:setupChildDevices() -- Setup Child Devices\n  local cdevs = api.get(\"/devices?parentId=\"..self.id) or {} -- Pick up all Child Devices\n  function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\n\n  if #cdevs == 0 then -- If no Child Devices, create them\n    local initChildData = { \n      {className=\"power\", name=\"Consumption\", type=\"com.fibaro.powerMeter\", value=0},\n      {className=\"powerProduction\", name=\"Production\", type=\"com.fibaro.powerMeter\", value=0},\n      {className=\"accumulatedConsumption\", name=\"Todays Consumption\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"accumulatedProduction\", name=\"Todays Production\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"accumulatedCost\", name=\"Todays Cost\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"accumulatedConsumptionLastHour\", name=\"Hourly Consumption\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"accumulatedProductionLastHour\", name=\"Hourly Production\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"lastMeterConsumption\", name=\"Total Consumption\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"lastMeterProduction\", name=\"Total Production\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"voltagePhase1\", name=\"Voltage L1\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"voltagePhase2\", name=\"Voltage L2\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"voltagePhase3\", name=\"Voltage L3\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"currentL1\", name=\"Ampere L1\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"currentL2\", name=\"Ampere L2\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"currentL3\", name=\"Ampere L3\", type=\"com.fibaro.electricMeter\", value=0},\n    }\n    for _,c in ipairs(initChildData) do\n      local ips = UI and self:makeInitialUIProperties(UI or {}) or {}\n      local child = self:createChildDevice(\n        {name = c.name,\n          type=c.type,\n          properties = {viewLayout = ips.viewLayout, uiCallbacks = ips.uiCallbacks},\n          interfaces = {\"quickApp\"}, \n        },\n        _G[c.className] -- Fetch class constructor from class name\n      )\n      child:setVariable(\"className\",c.className) -- Save class name so we know when we load it next time\n    end   \n  else \n    for _,child in ipairs(cdevs) do\n      local className = getChildVariable(child,\"className\") -- Fetch child class name\n      local childObject = _G[className](child) -- Create child object from the constructor's name\n      self.childDevices[child.id]=childObject\n      childObject.parent = self -- Setup parent link to device controller \n    end\n  end\nend\n\n\nfunction QuickApp:onInit()\n  __TAG = fibaro.getName(plugin.mainDeviceId) ..\" ID:\" ..plugin.mainDeviceId\n  self:debug(\"onInit\") \n\n  self:setupChildDevices() -- Setup the Child Devices\n\n  if not api.get(\"/devices/\"..self.id).enabled then\n    self:warning(\"Device\", fibaro.getName(plugin.mainDeviceId), \"is disabled\")\n    return\n  end\n  \n  self:getQuickAppVariables() \n  self:createVariables()\n  \n  if tonumber(debugLevel) == 4 then \n    self:simData() -- Offline Simulation Tibber Live\n  else\n    self:getData() -- Get data from the Tibber Live\n  end\nend\n "}]}