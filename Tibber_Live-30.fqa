{"name":"Tibber Live","type":"com.fibaro.powerMeter","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_114"},"sections":{"items":[{"components":[{"name":"label","style":{"weight":"1.2"},"text":"Label","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_114"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"debugLevel","type":"string","value":"1"},{"name":"reconnect","type":"string","value":"10"},{"name":"timeout","type":"string","value":"300"},{"name":"token","type":"string","value":"5K4MVS-OjfWhK_4yrjOlFe1F6kJXPVf7eQYggo8ebAE"},{"name":"homeId","type":"string","value":"96a14971-525a-4420-aae9-e5aedaa129ff"},{"name":"language","type":"string","value":"nl"},{"name":"homeNr","type":"string","value":"1"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":false,"content":"-- Tibber Live main\n\n\nfunction QuickApp:updateChildDevices() -- Update Child Devices\n  for id,child in pairs(self.childDevices) do \n    child:updateValue(data) \n  end\nend\n\n\nfunction QuickApp:logging(level,text) -- Logging function for debug\n  if tonumber(debugLevel) >= tonumber(level) then \n      self:debug(text)\n  end\nend\n\n\nfunction QuickApp:buttonEvent() -- Button event\n  self:logging(3, \"buttonEvent()\")\n  if connection then\n    connection = false\n    self:disconnectServer() -- Disconnect session\n    self:updateView(\"button\", \"text\", \"Click to re-connect\")\n    self:updateView(\"label\", \"text\", \"Disconnected from Tibber\")\n    self:updateProperty(\"log\", \"Disconnected\")\n  else \n    connection = true\n    self:getData()  -- Re-connect again\n    self:updateView(\"button\", \"text\", \"Disconnect\")\n  end\nend\n\n\nfunction QuickApp:updateProperties() -- Update the properties\n  self:logging(3,\"updateProperties() - Update the properties\")\n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.power-data.payload.data.liveMeasurement.powerProduction)))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", data.payload.data.liveMeasurement.timestamp)\nend\n\n\nfunction QuickApp:updateLabels() -- Update the labels\n  self:logging(3,\"updateLabels() - Update the labels\")\n\n  local labelText = \"\"\n  if debugLevel == 4 then\n    labelText = labelText ..translation[\"OFFLINE SIMULATION MODE\"] ..\"\\n\\n\"\n  end\n  if debugLevel == 5 then\n    labelText = labelText ..translation[\"LIVE TEST MODE\"] ..\"\\n\\n\"\n  end\n\n  labelText = labelText ..translation[\"Consumption\"] ..\": \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.power) ..\" Watt\" ..\"\\n\"\n  labelText = labelText ..translation[\"Production\"] ..\": \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.powerProduction) ..\" Watt\" ..\"\\n\\n\"\n  \n  labelText = labelText ..translation[\"Hourly Consumption\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedConsumptionLastHour) ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..translation[\"Hourly Production\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedProductionLastHour) ..\" kWh\" ..\"\\n\\n\"\n\n  labelText = labelText ..translation[\"Todays Consumption\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedConsumption) ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..translation[\"Min\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.minPower) ..\" - \" ..translation[\"Max\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.maxPower) ..\" - \" ..translation[\"Av\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.averagePower) ..\" Watt\" ..\"\\n\\n\"\n  \n  labelText = labelText ..translation[\"Todays Production\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.accumulatedProduction) ..\" kWh\" ..\"\\n\"\n  labelText = labelText ..translation[\"Min\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.minPowerProduction) ..\" - \" ..\" Max: \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.maxPowerProduction)..\" Watt\" ..\"\\n\\n\"\n  \n  labelText = labelText ..translation[\"Todays Cost\"] ..\": \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.accumulatedCost) ..\" \" ..data.payload.data.liveMeasurement.currency ..\"\\n\" \n  labelText = labelText ..translation[\"Reward\"] ..\": \" ..string.format(\"%.2f\",tonumber(data.payload.data.liveMeasurement.accumulatedReward)) ..\" \" ..data.payload.data.liveMeasurement.currency ..\"\\n\\n\" \n\n  labelText = labelText ..translation[\"Totals\"] ..\":\" ..\"\\n\" \n  labelText = labelText ..translation[\"Consumption\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.lastMeterConsumption) ..\" kWh\" ..\"\\n\" \n  labelText = labelText ..translation[\"Production\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.lastMeterProduction) ..\" kWh\" ..\"\\n\\n\" \n  \n  labelText = labelText ..translation[\"Voltage\"] ..\":\" ..\"\\n\"\n  labelText = labelText ..translation[\"L1\"] ..\": \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.voltagePhase1) ..\" - \" ..translation[\"L2\"] ..\": \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.voltagePhase2) ..\" - \" ..translation[\"L3\"] ..\": \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.voltagePhase3) ..\" Volt \" ..\"\\n\\n\"\n  \n  labelText = labelText ..translation[\"Ampere\"] ..\":\" ..\"\\n\"\n  labelText = labelText ..translation[\"L1\"] ..\": \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.currentL1) ..\" - \" ..translation[\"L2\"] ..\": \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.currentL2) ..\" - \" ..translation[\"L3\"] ..\": \" ..string.format(\"%.2f\",data.payload.data.liveMeasurement.currentL3) ..\" Amp \" ..\"\\n\\n\"\n  \n  labelText = labelText ..translation[\"Reactive Consumption\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.powerReactive) ..\" kVAr\" ..\"\\n\"\n  labelText = labelText ..translation[\"Reactive Production\"] ..\": \" ..string.format(\"%.1f\",data.payload.data.liveMeasurement.powerProductionReactive) ..\" kVAr\" ..\"\\n\"\n  labelText = labelText ..translation[\"Power Factor\"] ..\": \" ..string.format(\"%.3f\",data.payload.data.liveMeasurement.powerFactor) ..\" \" ..\"\\n\"\n  labelText = labelText ..translation[\"Signal strength\"] ..\": \" ..string.format(\"%.0f\",data.payload.data.liveMeasurement.signalStrength) \n  if tonumber(data.payload.data.liveMeasurement.signalStrength) >= 0 then\n    labelText = labelText ..\"%\" ..\"\\n\"\n  else\n    labelText = labelText ..\" dB\" ..\"\\n\"\n  end\n  labelText = labelText ..translation[\"Timestamp\"] ..\": \" ..data.payload.data.liveMeasurement.timestamp ..\"\\n\"\n\n  self:updateView(\"label\", \"text\", labelText)\n  self:logging(2,\"Label: \" ..labelText)\nend\n\n\nfunction QuickApp:getValues() -- Get the values from json file \n  self:logging(3,\"getValues() - Get the values from json file\")\n  local pattern = \"(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+).(%d+)+(%d+):(%d+)\" --2021-12-23T17:00:00.000+01:00\n  local runyear, runmonth, runday, runhour, runminute, runseconds = data.payload.data.liveMeasurement.timestamp:match(pattern)\n  local convertedTimestamp = os.time({year = runyear, month = runmonth, day = runday, hour = runhour, min = runminute, sec = runseconds})\n  data.payload.data.liveMeasurement.timestamp = os.date(\"%d-%m-%Y %H:%M:%S\", convertedTimestamp)\n  \n  self:logging(2,\"data: \" ..json.encode(data))\n  data = json.encode(data):gsub(\"null\", '\"null\"') -- Clean up the response by replacing null with \"null\"\n  data = json.decode(data) \n\n  -- Check for null values and replace them with previous values\n  if data.payload.data.liveMeasurement.voltagePhase1 == \"null\" or data.payload.data.liveMeasurement.voltagePhase1 == nil or data.payload.data.liveMeasurement.voltagePhase1 == 0 then -- Also replace zero values for Voltage\n    self:logging(3,\"Replaced voltagePhase1 \" ..data.payload.data.liveMeasurement.voltagePhase1 ..\" with: \" ..prevdata.voltagePhase1)\n    data.payload.data.liveMeasurement.voltagePhase1 = tonumber(prevdata.voltagePhase1)\n  else\n    prevdata.voltagePhase1 = data.payload.data.liveMeasurement.voltagePhase1 \n  end\n  if data.payload.data.liveMeasurement.voltagePhase2 == \"null\" or data.payload.data.liveMeasurement.voltagePhase2 == nil or data.payload.data.liveMeasurement.voltagePhase2 == 0 then -- Also replace zero values for Voltage\n    self:logging(3,\"Replaced voltagePhase2 \" ..data.payload.data.liveMeasurement.voltagePhase2 ..\" with: \" ..prevdata.voltagePhase2)\n    data.payload.data.liveMeasurement.voltagePhase2 = tonumber(prevdata.voltagePhase2)\n  else\n    prevdata.voltagePhase2 = data.payload.data.liveMeasurement.voltagePhase2\n  end\n  if data.payload.data.liveMeasurement.voltagePhase3 == \"null\" or data.payload.data.liveMeasurement.voltagePhase3 == nil or data.payload.data.liveMeasurement.voltagePhase3 == 0 then -- Also replace zero values for Voltage\n    self:logging(3,\"Replaced voltagePhase3 \" ..data.payload.data.liveMeasurement.voltagePhase3 ..\" with: \" ..prevdata.voltagePhase3)\n    data.payload.data.liveMeasurement.voltagePhase3 = tonumber(prevdata.voltagePhase3)\n  else\n    prevdata.voltagePhase3 = data.payload.data.liveMeasurement.voltagePhase3\n  end\n  \n  if data.payload.data.liveMeasurement.currentL1 == \"null\" or data.payload.data.liveMeasurement.currentL1 == nil then\n    self:logging(3,\"Replaced currentL1 \" ..data.payload.data.liveMeasurement.currentL1 ..\" with: \" ..prevdata.currentL1)\n    data.payload.data.liveMeasurement.currentL1 = tonumber(prevdata.currentL1)\n  else\n    prevdata.currentL1 = data.payload.data.liveMeasurement.currentL1\n  end\n  if data.payload.data.liveMeasurement.currentL2 == \"null\" or data.payload.data.liveMeasurement.currentL2 == nil then\n    self:logging(3,\"Replaced currentL2 \" ..data.payload.data.liveMeasurement.currentL2 ..\" with: \" ..prevdata.currentL2)\n    data.payload.data.liveMeasurement.currentL2 = tonumber(prevdata.currentL2)\n  else\n    prevdata.currentL2 = data.payload.data.liveMeasurement.currentL2\n  end\n  if data.payload.data.liveMeasurement.currentL3 == \"null\" or data.payload.data.liveMeasurement.currentL3 == nil then\n    self:logging(3,\"Replaced currentL3 \" ..data.payload.data.liveMeasurement.currentL3 ..\" with: \" ..prevdata.currentL3)\n    data.payload.data.liveMeasurement.currentL3 = tonumber(prevdata.currentL3)\n  else\n    prevdata.currentL3 = data.payload.data.liveMeasurement.currentL3\n  end\n  \n  if data.payload.data.liveMeasurement.powerFactor == \"null\" or data.payload.data.liveMeasurement.powerFactor == nil then\n    self:logging(3,\"Replaced powerFactor \" ..data.payload.data.liveMeasurement.powerFactor ..\" with: \" ..prevdata.powerFactor)\n    data.payload.data.liveMeasurement.powerFactor = tonumber(prevdata.powerFactor)\n  else\n    prevdata.powerFactor = data.payload.data.liveMeasurement.powerFactor \n  end\n  if data.payload.data.liveMeasurement.powerReactive == \"null\" or data.payload.data.liveMeasurement.powerReactive == nil then\n    self:logging(3,\"Replaced powerReactive \" ..data.payload.data.liveMeasurement.powerReactive ..\" with: \" ..prevdata.powerReactive)\n    data.payload.data.liveMeasurement.powerReactive = tonumber(prevdata.powerReactive)\n  else\n    prevdata.powerReactive = data.payload.data.liveMeasurement.powerReactive\n  end\n  if data.payload.data.liveMeasurement.powerProductionReactive == \"null\" or data.payload.data.liveMeasurement.powerProductionReactive == nil then\n    self:logging(3,\"Replaced powerProductionReactive \" ..data.payload.data.liveMeasurement.powerProductionReactive ..\" with: \" ..prevdata.powerProductionReactive)\n    data.payload.data.liveMeasurement.powerProductionReactive = tonumber(prevdata.powerProductionReactive)\n  else\n    prevdata.powerProductionReactive = data.payload.data.liveMeasurement.powerProductionReactive\n  end\n  if data.payload.data.liveMeasurement.signalStrength == \"null\" or data.payload.data.liveMeasurement.signalStrength == nil then\n    self:logging(3,\"Replaced signalStrength \" ..data.payload.data.liveMeasurement.signalStrength ..\" with: \" ..prevdata.signalStrength)\n    data.payload.data.liveMeasurement.signalStrength = tonumber(prevdata.signalStrength)\n  else\n    prevdata.signalStrength = data.payload.data.liveMeasurement.signalStrength\n  end\n  \n  if data.payload.data.liveMeasurement.accumulatedReward == \"null\" or data.payload.data.liveMeasurement.accumulatedReward == nil then\n    self:logging(3,\"Replaced accumulatedReward \" ..data.payload.data.liveMeasurement.accumulatedReward ..\" with: \" ..prevdata.accumulatedReward)\n    data.payload.data.liveMeasurement.accumulatedReward = tonumber(prevdata.accumulatedReward)\n  else\n    prevdata.accumulatedReward = data.payload.data.liveMeasurement.accumulatedReward\n  end\n  if data.payload.data.liveMeasurement.accumulatedCost == \"null\" or data.payload.data.liveMeasurement.accumulatedCost == nil then\n    self:logging(3,\"Replaced accumulatedCost \" ..data.payload.data.liveMeasurement.accumulatedCost ..\" with: \" ..prevdata.accumulatedCost)\n    data.payload.data.liveMeasurement.accumulatedCost = tonumber(prevdata.accumulatedCost)\n  else\n    prevdata.accumulatedCost = data.payload.data.liveMeasurement.accumulatedCost\n  end\n  if data.payload.data.liveMeasurement.currency == \"null\" or data.payload.data.liveMeasurement.currency == nil then\n    self:logging(3,\"Replaced currency \" ..data.payload.data.liveMeasurement.currency ..\" with: \" ..prevdata.currency)\n    data.payload.data.liveMeasurement.currency = prevdata.currency\n  else\n    prevdata.currency = data.payload.data.liveMeasurement.currency\n  end\n  data = json.encode(data):gsub(\"null\", 0) -- Clean up the response by replacing null with 0\n  data = json.decode(data) \n\n  self:logging(2,\"data (without null): \" ..json.encode(data))\nend\n\n\nfunction QuickApp:handleError(error) -- An error occured\n  self:logging(3,\"handleError() - An error occured\")\n  self:error(\"WebSocket error: \", error)\n    self:updateView(\"label\", \"text\", \"WebSocket error: \", error)\n  if reconnect > 0 then -- re-connect n times\n    self:logging(3,\"Trying to reconnect ... (\" ..tonumber(reconnect) ..\")\")\n    fibaro.setTimeout(math.random(10,15)*1000, function() -- Random (jitter) reconnection between 10 and 15 seconds\n      self:getData()\n    end)\n    reconnect = reconnect - 1 \n  else -- Never disconnect, retry to re-connect after n seconds\n    reconnect = tonumber(self:getVariable(\"reconnect\"))\n    self:logging(3,\"SetTimeout for re-connect about ± \" ..timeout ..\" seconds\")\n    fibaro.setTimeout((math.random(1,10)+timeout)*1000, function() -- Random (jitter) reconnection interval plus between 1 and 10 seconds\n      if timeout < (tonumber(self:getVariable(\"reconnect\"))*10) then -- Check for maximum increase \n        timeout = timeout*1.2 -- Increase the timeout for exponential backoff (increasing delay)\n      end\n      self:getData()\n    end)\n  end\nend\n\n\nfunction QuickApp:handleDisconnected() -- The client or the server closed the socket\n  self:logging(3,\"handleDisconnected() - The client or the server closed the socket\")\n  if reconnect > 0 then -- re-connect n times\n    self:logging(3,\"Trying to reconnect ... (\" ..tonumber(reconnect) ..\")\")\n    fibaro.setTimeout(math.random(10,15)*1000, function() -- Random (jitter) reconnection between 10 and 15 seconds\n      self:getData()\n    end)\n    reconnect = reconnect - 1 \n  else -- Never disconnect, retry to re-connect after n seconds\n    reconnect = tonumber(self:getVariable(\"reconnect\"))\n    self:logging(3,\"SetTimeout for re-connect about ± \" ..timeout ..\" seconds\")\n    fibaro.setTimeout((math.random(1,10)+timeout)*1000, function() -- Random (jitter) reconnection interval plus between 1 and 10 seconds\n      if timeout < (tonumber(self:getVariable(\"reconnect\"))*10) then -- Check for maximum increase \n        timeout = timeout*1.2 -- Increase the timeout for exponential backoff (increasing delay)\n      end\n      self:getData()\n    end)\n  end\nend\n\n\nfunction QuickApp:disconnectServer() -- Closes the connection to the server\n  self:logging(3,\"disconnectServer() - Closes the connection to the server\")\n  self.sock:close()   \n  self:logging(1,\"Closed the connection with the Tibber server\")\nend\n\n\nfunction QuickApp:handleDataReceived(resp) -- Handle data received by the socket\n  self:logging(3,\"handleDataReceived() - Handle data received by the socket\")\n  data = json.decode(resp) \n\n  if not connection then \n    -- Do nothing, the connection should be closed\n    self:logging(1,\"Tibber tries to re-connect: \" ..data.type) -- Ignore the re-connect from Tibber\n  elseif data.type == \"connection_ack\" then -- The initial connection is there, please send the query body\n    self:logging(3,\"Got connection_ack, making and sending query\")\n    self:logging(3,\"graphql_query_body: \" ..graphql_query_body)\n    self.sock:send(graphql_query_body)\n  elseif data.type == \"next\" then -- Tibber Live responded with next (new Tibber response)\n    reconnect = tonumber(self:getVariable(\"reconnect\")) -- Reset reconnect to is initial value\n    self:getValues()\n    self:updateLabels()\n    self:updateProperties()\n\n    if os.date(\"%M\") ~= (timer or \"99\") then -- Update the child devices only every minute (to minimize CPU load)\n      self:logging(3,\"updateChildDevices\")\n      self:updateChildDevices() \n      timer = os.date(\"%M\")\n    end\n  else -- Something else is going on \n    self:logging(2,\"Data not handled in handleDataReceived: \"..data.type) -- Maybe change due to disconnectServer()\n  end\nend\n\n\nfunction QuickApp:handleConnected() -- Initialize the connection \n  self:logging(3,\"handleConnected() - Initialize the connection\")\n  self.sock:send('{\"type\": \"connection_init\", \"payload\": {}}') -- Only initialize the connection \nend\n\n\nfunction QuickApp:simData() -- Offline Simulation Tibber Live\n  self:logging(3,\"simData() - Offline Simulation Tibber Live\")\n  local resp = '{\"id\":\"1\",\"payload\":{\"data\":{\"liveMeasurement\":{\"currency\":\"SEK\",\"averagePower\":4574,\"minPowerProduction\":0,\"lastMeterConsumption\":36768.038,\"powerFactor\":0.878,\"signalStrength\":0,\"lastMeterProduction\":6411.939,\"powerProduction\":0,\"voltagePhase3\":231.5,\"voltagePhase2\":229.2,\"maxPowerProduction\":0,\"powerReactive\":0,\"timestamp\":\"20-11-2022T12:11:24\",\"powerProductionReactive\":1496,\"maxPower\":8431,\"currentL3\":4.1,\"accumulatedConsumptionLastHour\":0.674,\"voltagePhase1\":229.4,\"currentL2\":4.3,\"currentL1\":6.6,\"power\":2746,\"accumulatedConsumption\":55.77,\"accumulatedReward\":0,\"accumulatedProductionLastHour\":0,\"accumulatedCost\":151.588522,\"accumulatedProduction\":0,\"minPower\":1558}}},\"type\":\"next\"}' -- New Tibber response\n\n  data = json.decode(resp) -- Decode the json string from api to lua-table \n\n  self:getValues()\n  self:updateLabels()\n  self:updateProperties()\n  self:updateChildDevices() \n  \n  local interval = 10\n  self:logging(3,\"SetTimeout \" ..interval ..\" seconds\")\n  fibaro.setTimeout(interval*1000, function() \n     self:simData()\n  end)\nend\n\n\nfunction QuickApp:getData() -- Get the data from Tibber\n  self:logging(3,\"getData() - Get the data from Tibber\")\n  self.sock = net.WebSocketClientTls()\n  self.sock:addEventListener(\"connected\", function() self:handleConnected() end)\n  self.sock:addEventListener(\"disconnected\", function() self:handleDisconnected() end)\n  self.sock:addEventListener(\"error\", function(error) self:handleError(error) end)\n  self.sock:addEventListener(\"dataReceived\", function(next) self:handleDataReceived(next) end) -- New Tibber Returning message type\n\n  self:logging(3,\"Connect: \" ..url ..\" \" ..json.encode(headers))\n  self.sock:connect(url, headers)\nend\n\n\nfunction QuickApp:checkEnabled() -- Check realTimeConsumptionEnabled at Tibber\n  self:logging(3,\"checkEnabled() - Check realTimeConsumptionEnabled at Tibber\")\n  data = os.date(\"*t\")\n  local url = \"https://api.tibber.com/v1-beta/gql\"\n  --local requestBody = '{viewer {home(id: \"96a14971-525a-4420-aae9-e5aedaa129ff\") {features {realTimeConsumptionEnabled}}}}'\n  local requestBody = '{\"query\": \"{viewer {homes{features{realTimeConsumptionEnabled}}}}\"}'\n\n  self:logging(3,\"requestBody: \" ..requestBody)\n\n  http:request(url, {\n    options = {\n      data = requestBody,\n      method = \"POST\",\n      headers = {\n        [\"Content-Type\"] = \"application/json\",\n        [\"Accept\"] = \"application/json\",\n        [\"Authorization\"] = \"Bearer \" ..token,\n        [\"User-Agent\"] = \"Tibber_Live/2.4 Fibaro/HC3 Firmware/\" ..api.get(\"/settings/info\").softVersion -- Tibber user-agent\n      }\n    },\n    success = function(response) \n        self:logging(3,\"response status: \" ..response.status)\n        self:logging(3,\"headers: \" ..response.headers[\"Content-Type\"])\n        self:logging(3,\"Response data: \" ..response.data)\n\n        if response.data == nil or response.data == \"\" or response.data == \"[]\" or response.status > 200 or (os.date(\"%H:%M\") <= \"00:05\") then -- Check for empty result or skip for midnight empty results\n          if os.date(\"%H:%M\") < \"00:05\" then\n            self:warning(\"No production data from Tibber Monitor between 00:00 and 00:05\")\n          else\n            self:warning(\"Temporarily no production data from Tibber\")\n          end\n          return\n        end\n\n        response.data = response.data:gsub(\"null\", \"0\") -- clean up the response.data by replacing null with 0\n        --self:logging(3,\"Response data without null: \" ..response.data)\n        \n        -- response = {\"data\":{\"viewer\":{\"homes\":[{\"features\":{\"realTimeConsumptionEnabled\":true}}]}}}\n\n        jsonTable = json.decode(response.data) -- JSON decode from api to lua-table\n        self:logging(3,\"jsonTable\" ..json.encode(jsonTable))\n        realTimeConsumptionEnabled = (jsonTable.data.viewer.homes[homeNr].features.realTimeConsumptionEnabled) or \"empty\"\n      end,\n      error = function(error)\n        self:error(\"error: \" ..json.encode(error))\n        self:updateProperty(\"log\", \"error: \" ..json.encode(error))\n      end\n    }) \n  self:logging(3,\"SetTimeout 5 seconds\")\n  fibaro.setTimeout(5*1000, function() \n    if realTimeConsumptionEnabled then\n      print(\"realTimeConsumptionEnabled = true\")\n    else\n      print(\"realTimeConsumptionEnabled = false\")\n    end\n  end)\nend\n\n\nfunction QuickApp:createVariables() -- Create all Variables \n  self:logging(3,\"createVariables() - Create all Variables \")\n  url = \"wss://websocket-api.tibber.com/v1-beta/gql/subscriptions\" -- New Tibber Live webSocket URL\n  data = {} -- Table for Tibber response\n  connection = true\n  prevdata = {} -- Table for previous values to replace null values\n  prevdata.voltagePhase1 = 0\n  prevdata.voltagePhase2 = 0\n  prevdata.voltagePhase3 = 0\n  prevdata.currentL1 = 0\n  prevdata.currentL2 = 0\n  prevdata.currentL3 = 0\n  prevdata.powerFactor = 0\n  prevdata.powerReactive = 0\n  prevdata.signalStrength = 0\n  prevdata.powerProductionReactive = 0\n  prevdata.accumulatedReward = 0\n  prevdata.accumulatedCost = 0\n  prevdata.accumulatedConsumption = 0 -- Extra for calculation current price (experimental feature)\n  prevdata.accumulatedProduction = 0 -- Extra for calculation current price (experimental feature)\n  prevdata.currency = \"EUR\"\n  \n  headers = {} -- Headers for authorization and protocol\n  headers[\"Authorization\"] = token\n  headers[\"Sec-WebSocket-Protocol\"] = \"graphql-transport-ws\" -- New Tibber header protocol\n  headers[\"User-Agent\"] = \"Tibber_Live/2.4 Fibaro/HC3 Firmware/\" ..api.get(\"/settings/info\").softVersion -- New Tibber mandatory user-agent\n  \n  local graphql_query = {} -- Query for Subscription Live Measurement\n  graphql_query.type = \"subscribe\" -- New Tibber graphql_query.type\n  graphql_query.id = \"1\"\n  graphql_query.payload = {}\n  graphql_query.payload.query = 'subscription{liveMeasurement(homeId:\"' ..homeId ..'\"){power maxPower powerProduction maxPowerProduction accumulatedConsumption accumulatedProduction accumulatedCost currency lastMeterConsumption lastMeterProduction voltagePhase1 voltagePhase2 voltagePhase3 currentL1 currentL2 currentL3 accumulatedConsumptionLastHour accumulatedProductionLastHour accumulatedReward minPower averagePower powerReactive powerProductionReactive minPowerProduction powerFactor signalStrength timestamp}}'\n  graphql_query_body = json.encode(graphql_query)\n  translation = i18n:translation(string.lower(self:getVariable(\"language\"))) -- Initialise the translation\nend\n\n\nfunction QuickApp:getQuickAppVariables() -- Check existence of the mandatory variables, if not, create them with default values\n  token = self:getVariable(\"token\")\n  homeId = self:getVariable(\"homeId\")\n  homeNr = tonumber(self:getVariable(\"homeNr\"))\n  local language = string.lower(self:getVariable(\"language\"))\n  reconnect = tonumber(self:getVariable(\"reconnect\"))\n  timeout = tonumber(self:getVariable(\"timeout\"))\n  debugLevel = tonumber(self:getVariable(\"debugLevel\"))\n\n  if debugLevel == \"\" or debugLevel == nil then\n    debugLevel = \"1\" -- Default debug level\n    self:setVariable(\"debugLevel\",debugLevel)\n    self:trace(\"Added QuickApp variable debugLevel\")\n    debugLevel = tonumber(debugLevel)\n  end\n  if token == \"\" or token == nil or token == \"0\" then\n    token = \"5K4MVS-OjfWhK_4yrjOlFe1F6kJXPVf7eQYggo8ebAE\" -- This token is just an demo/test example, only for demo/test purposes\n    self:setVariable(\"token\",token)\n    self:trace(\"Added QuickApp variable with DEMO (!) token. Get your token from the Tibber website and parse it to the quickapp variable\")\n    debugLevel = 4 -- Offline Simulation Mode due to DEMO token\n    self:warning(\"Switched to Offline Simulation Mode\")\n  end\n  if homeId == \"\" or homeId == nil or homeId == \"0\" then\n    homeId = \"96a14971-525a-4420-aae9-e5aedaa129ff\"-- This Home ID is just an demo/test example, only for demo/test purposes\n    self:setVariable(\"homeId\",homeId)\n    self:trace(\"Added QuickApp variable with DEMO (!) Home ID. Get your Home ID from the Tibber website and parse it to the quickapp variable\")\n    debugLevel = 4 -- Offline Simulation Mode due to DEMO Home ID\n    self:warning(\"Switched to Offline Simulation Mode\")\n  end\n  if homeNr == \"\" or homeNr == nil then\n    homeNr = \"1\"\n    self:setVariable(\"homeNr\",homeNr)\n    self:trace(\"Added QuickApp variable homeNr\")\n    homeNr = tonumber(homeNr)\n  end\n  if language == \"\" or language == nil or type(i18n:translation(string.lower(self:getVariable(\"language\")))) ~= \"table\" then\n    language = \"en\" \n    self:setVariable(\"language\",language)\n    self:trace(\"Added QuickApp variable language\")\n  end\n  if reconnect == \"\" or reconnect == nil then\n    reconnect = \"10\" -- Default amount of re-connects \n    self:setVariable(\"reconnect\",reconnect)\n    self:trace(\"Added QuickApp variable reconnect\")\n    reconnect = tonumber(reconnect)\n  end\n  if timeout == \"\" or timeout == nil or timeout == 0 then\n    timeout = \"300\" -- Default timeout after maximum re-connects in seconds\n    self:setVariable(\"timeout\",timeout)\n    self:trace(\"Added QuickApp variable timeout\")\n    timeout = tonumber(timeout)\n  end\n  if debuglevel == 5 then -- Live Test Mode\n    token = \"5K4MVS-OjfWhK_4yrjOlFe1F6kJXPVf7eQYggo8ebAE\" -- This token is just an demo/test example, only for demo/test purposes\n    homeId = \"96a14971-525a-4420-aae9-e5aedaa129ff\" -- This Home ID is just an demo/test example, only for demo/test purposes\n    self:warning(\"DebugLevel = 5 (Live Test mode): Changed Tibber Token and Home ID to Tibber TEST values\")\n  end\nend\n\n\nlocal function getChildVariable(child,varName)\n  for _,v in ipairs(child.properties.quickAppVariables or {}) do\n    if v.name==varName then return v.value end\n  end\n  return \"\"\nend\n\n\nfunction QuickApp:setupChildDevices() -- Setup Child Devices\n  local cdevs = api.get(\"/devices?parentId=\"..self.id) or {} -- Pick up all Child Devices\n  function self:initChildDevices() end -- Null function, else Fibaro calls it after onInit()...\n\n  if #cdevs == 0 then -- If no Child Devices, create them\n    local initChildData = { \n      {className=\"power\", name=\"Consumption\", type=\"com.fibaro.powerMeter\", value=0},\n      {className=\"powerProduction\", name=\"Production\", type=\"com.fibaro.powerMeter\", value=0},\n      {className=\"accumulatedConsumption\", name=\"Todays Consumption\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"accumulatedProduction\", name=\"Todays Production\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"accumulatedCost\", name=\"Todays Cost\", type=\"com.fibaro.multilevelSensor\", value=0},\n      {className=\"accumulatedConsumptionLastHour\", name=\"Hourly Consumption\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"accumulatedProductionLastHour\", name=\"Hourly Production\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"lastMeterConsumption\", name=\"Total Consumption\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"lastMeterProduction\", name=\"Total Production\", type=\"com.fibaro.energyMeter\", value=0},\n      {className=\"voltagePhase1\", name=\"Voltage L1\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"voltagePhase2\", name=\"Voltage L2\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"voltagePhase3\", name=\"Voltage L3\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"currentL1\", name=\"Ampere L1\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"currentL2\", name=\"Ampere L2\", type=\"com.fibaro.electricMeter\", value=0},\n      {className=\"currentL3\", name=\"Ampere L3\", type=\"com.fibaro.electricMeter\", value=0},\n    }\n    for _,c in ipairs(initChildData) do\n      local ips = UI and self:makeInitialUIProperties(UI or {}) or {}\n      local child = self:createChildDevice(\n        {name = c.name,\n          type=c.type,\n          properties = {viewLayout = ips.viewLayout, uiCallbacks = ips.uiCallbacks},\n          interfaces = {\"quickApp\"}, \n        },\n        _G[c.className] -- Fetch class constructor from class name\n      )\n      child:setVariable(\"className\",c.className) -- Save class name so we know when we load it next time\n    end   \n  else \n    for _,child in ipairs(cdevs) do\n      local className = getChildVariable(child,\"className\") -- Fetch child class name\n      local childObject = _G[className](child) -- Create child object from the constructor's name\n      self.childDevices[child.id]=childObject\n      childObject.parent = self -- Setup parent link to device controller \n    end\n  end\nend\n\n\nfunction QuickApp:onInit() -- Initialise the QuickApp\n  __TAG = fibaro.getName(plugin.mainDeviceId) ..\" ID:\" ..plugin.mainDeviceId\n  self:debug(\"onInit() - Initialise the QuickApp\") \n\n  self:setupChildDevices() -- Setup the Child Devices\n\n  if not api.get(\"/devices/\"..self.id).enabled then\n    self:warning(\"Device\", fibaro.getName(plugin.mainDeviceId), \"is disabled\")\n    return\n  end\n\n  self:getQuickAppVariables() \n  self:createVariables()\n  \n  http = net.HTTPClient({timeout=5*1000}) -- To check home.features.realTimeConsumptionEnabled\n\n  --self:checkEnabled() \n\n  if tonumber(debugLevel) == 4 then \n    self:simData() -- Offline Simulation Tibber Live\n  else\n    self:getData() -- Get data from the Tibber Live\n  end\nend\n \n -- EOF "},{"name":"childs","isMain":false,"isOpen":false,"content":"-- Tiber Live Classes Child Devices\n\n\nclass 'power'(QuickAppChild)\nfunction power:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction power:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.power)))\n  self:updateProperty(\"power\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.power)))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", translation[\"Max\"] ..\" \" ..data.payload.data.liveMeasurement.maxPower ..\" Watt\")\nend\n\nclass 'powerProduction'(QuickAppChild)\nfunction powerProduction:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction powerProduction:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.powerProduction)))\n  self:updateProperty(\"power\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.powerProduction)))\n  self:updateProperty(\"unit\", \"Watt\")\n  self:updateProperty(\"log\", translation[\"Max\"] ..\" \" ..data.payload.data.liveMeasurement.maxPowerProduction ..\" Watt\")\nend\n\nclass 'accumulatedConsumption'(QuickAppChild)\nfunction accumulatedConsumption:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"consumption\" then \n    self:updateProperty(\"rateType\", \"consumption\")\n    self:warning(\"Changed rateType interface of Todays Consumption child device (\" ..self.id ..\") to consumption\")\n  end\nend\nfunction accumulatedConsumption:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedConsumption)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'accumulatedProduction'(QuickAppChild)\nfunction accumulatedProduction:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n    self:warning(\"Changed rateType interface of Todays Production child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction accumulatedProduction:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedProduction)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'accumulatedCost'(QuickAppChild)\nfunction accumulatedCost:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction accumulatedCost:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedCost)))\n  self:updateProperty(\"unit\", data.payload.data.liveMeasurement.currency)\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'accumulatedConsumptionLastHour'(QuickAppChild)\nfunction accumulatedConsumptionLastHour:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"consumption\" then \n    self:updateProperty(\"rateType\", \"consumption\")\n    self:warning(\"Changed rateType interface of Last Hour Consumption child device (\" ..self.id ..\") to consumption\")\n  end\nend\nfunction accumulatedConsumptionLastHour:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedConsumptionLastHour)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'accumulatedProductionLastHour'(QuickAppChild)\nfunction accumulatedProductionLastHour:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n    self:warning(\"Changed rateType interface of Last Hour Production child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction accumulatedProductionLastHour:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.accumulatedProductionLastHour)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'lastMeterConsumption'(QuickAppChild)\nfunction lastMeterConsumption:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"consumption\" then \n    self:updateProperty(\"rateType\", \"consumption\")\n    self:warning(\"Changed rateType interface of Total Consumption child device (\" ..self.id ..\") to consumption\")\n  end\nend\nfunction lastMeterConsumption:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.lastMeterConsumption)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'lastMeterProduction'(QuickAppChild)\nfunction lastMeterProduction:__init(dev)\n  QuickAppChild.__init(self,dev)\n  if fibaro.getValue(self.id, \"rateType\") ~= \"production\" then \n    self:updateProperty(\"rateType\", \"production\")\n    self:warning(\"Changed rateType interface of Total Production child device (\" ..self.id ..\") to production\")\n  end\nend\nfunction lastMeterProduction:updateValue(data) \n  self:updateProperty(\"value\", tonumber(string.format(\"%.3f\",data.payload.data.liveMeasurement.lastMeterProduction)))\n  self:updateProperty(\"unit\", \"kWh\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'voltagePhase1'(QuickAppChild)\nfunction voltagePhase1:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction voltagePhase1:updateValue(data) \n  prevdata.voltagePhase1 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.voltagePhase1)))\n  self:updateProperty(\"unit\", \"Volt\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'voltagePhase2'(QuickAppChild)\nfunction voltagePhase2:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction voltagePhase2:updateValue(data) \n  prevdata.voltagePhase2 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.voltagePhase2)))\n  self:updateProperty(\"unit\", \"Volt\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'voltagePhase3'(QuickAppChild)\nfunction voltagePhase3:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction voltagePhase3:updateValue(data) \n  prevdata.voltagePhase3 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.voltagePhase3)))\n  self:updateProperty(\"unit\", \"Volt\")\n  self:updateProperty(\"log\", \" \")\nend\n\nclass 'currentL1'(QuickAppChild)\nfunction currentL1:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction currentL1:updateValue(data) \n  prevdata.currentL1 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.currentL1)))\n  self:updateProperty(\"unit\", \"Amp\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'currentL2'(QuickAppChild)\nfunction currentL2:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction currentL2:updateValue(data) \n  prevdata.currentL2 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.currentL2)))\n  self:updateProperty(\"unit\", \"Amp\")\n  self:updateProperty(\"log\", \"\")\nend\n\nclass 'currentL3'(QuickAppChild)\nfunction currentL3:__init(dev)\n  QuickAppChild.__init(self,dev)\nend\nfunction currentL3:updateValue(data) \n  prevdata.currentL2 = tonumber(self.properties.value) -- Save the latest value to replace null values\n  self:updateProperty(\"value\", tonumber(string.format(\"%.1f\",data.payload.data.liveMeasurement.currentL3)))\n  self:updateProperty(\"unit\", \"Amp\")\n  self:updateProperty(\"log\", \"\")\nend\n\n-- EOF "},{"name":"i18n","isMain":false,"isOpen":false,"content":"-- Tibber Live i18n Translations\n\n\nclass \"i18n\"\nfunction i18n:translation(language)\n  translation = {\n    en = {\n      [\"OFFLINE SIMULATION MODE\"] = \"OFFLINE SIMULATION MODE\", \n      [\"LIVE TEST MODE\"] = \"LIVE TEST MODE\", \n      [\"Consumption\"] = \"Consumption\", \n      [\"Production\"] = \"Production\", \n      [\"Hourly Consumption\"] = \"Hourly Consumption\", \n      [\"Hourly Production\"] = \"Hourly Production\", \n      [\"Todays Consumption\"] = \"Todays Consumption\", \n      [\"Min\"] = \"Min\", \n      [\"Max\"] = \"Max\", \n      [\"Av\"] = \"Av\", \n      [\"Todays Production\"] = \"Todays Production\", \n      [\"Todays Cost\"] = \"Todays Cost\", \n      [\"Reward\"] = \"Reward\", \n      [\"Totals\"] = \"Totals\", \n      [\"Voltage\"] = \"Voltage\", \n      [\"L1\"] = \"L1\", \n      [\"L2\"] = \"L2\", \n      [\"L3\"] = \"L3\", \n      [\"Ampere\"] = \"Ampere\", \n      [\"Reactive Consumption\"] = \"Reactive Consumption\", \n      [\"Reactive Production\"] = \"Reactive Production\", \n      [\"Power Factor\"] = \"Power Factor\", \n      [\"Signal strength\"] = \"Signal strength\", \n      [\"Timestamp\"] = \"Timestamp\"}, \n    nl = {\n      [\"OFFLINE SIMULATION MODE\"] = \"OFFLINE SIMULATIE MODE\", \n      [\"LIVE TEST MODE\"] = \"LIVE TEST MODE\", \n      [\"Consumption\"] = \"Consumptie\", \n      [\"Production\"] = \"Productie\", \n      [\"Hourly Consumption\"] = \"Uurconsumptie\", \n      [\"Hourly Production\"] = \"Uurproductie\", \n      [\"Todays Consumption\"] = \"Consumptie vandaag\", \n      [\"Min\"] = \"Min\", \n      [\"Max\"] = \"Max\", \n      [\"Av\"] = \"Gem\", \n      [\"Todays Production\"] = \"Productie vandaag\", \n      [\"Todays Cost\"] = \"Kosten vandaag\", \n      [\"Reward\"] = \"Beloning\", \n      [\"Totals\"] = \"Totalen\", \n      [\"Voltage\"] = \"Voltage\", \n      [\"L1\"] = \"F1\", \n      [\"L2\"] = \"F2\", \n      [\"L3\"] = \"F3\", \n      [\"Ampere\"] = \"Ampère\", \n      [\"Reactive Consumption\"] = \"Reactieve Consumptie\", \n      [\"Reactive Production\"] = \"Reactieve Productie\", \n      [\"Power Factor\"] = \"Power Factor\", \n      [\"Signal strength\"] = \"Signaal sterkte\", \n      [\"Timestamp\"] = \"Datum/tijd\"}, \n    se = {\n      [\"OFFLINE SIMULATION MODE\"] = \"OFFLINE SIMULERINGSLÄGE\",\n      [\"LIVE TEST MODE\"] = \"LIVE TESTLÄGE\",\n      [\"Consumption\"] = \"Förbrukning\",\n      [\"Production\"] = \"Produktion\",\n      [\"Hourly Consumption\"] = \"Timförbrukning\",\n      [\"Hourly Production\"] = \"Timproduktion\",\n      [\"Todays Consumption\"] = \"Dagens förbrukning\",\n      [\"Min\"] = \"Min\",\n      [\"Max\"] = \"Max\",\n      [\"Av\"] = \"Medel\",\n      [\"Todays Production\"] = \"Dagens produktion\",\n      [\"Todays Cost\"] = \"Dagens kostnad\",\n      [\"Reward\"] = \"Belöning\",\n      [\"Totals\"] = \"Summor\",\n      [\"Voltage\"] = \"Volt\",\n      [\"L1\"] = \"Fas1\",\n      [\"L2\"] = \"Fas2\",\n      [\"L3\"] = \"Fas3\",\n      [\"Ampere\"] = \"Amper\",\n      [\"Reactive Consumption\"] = \"Reaktiv förbrukning\",\n      [\"Reactive Production\"] = \"Reaktiv produktion\",\n      [\"Power Factor\"] = \"Effektfaktor\",\n      [\"Signal strength\"] = \"Signalstyrka\",\n      [\"Timestamp\"] = \"Tidsstämpel\"},\n    no = {\n    [\"OFFLINE SIMULATION MODE\"] = \"OFFLINE SIMULASJONSMODUS\", \n      [\"LIVE TEST MODE\"] = \"LIVE TEST MODUS\", \n      [\"Consumption\"] = \"Forbruk\", \n      [\"Production\"] = \"Produksjon\", \n      [\"Hourly Consumption\"] = \"Forbruk pr time\", \n      [\"Hourly Production\"] = \"Produksjon pr time\", \n      [\"Todays Consumption\"] = \"Dagens forbruk\", \n      [\"Min\"] = \"Min\", \n      [\"Max\"] = \"Max\", \n      [\"Av\"] = \"Av\", \n      [\"Todays Production\"] = \"Dagens produksjon\", \n      [\"Todays Cost\"] = \"Dagens kostnad\", \n      [\"Reward\"] = \"Fortjeneste\", \n      [\"Totals\"] = \"Totalt\", \n      [\"Voltage\"] = \"Volt\", \n      [\"L1\"] = \"L1\", \n      [\"L2\"] = \"L2\", \n      [\"L3\"] = \"L3\", \n      [\"Ampere\"] = \"Ampere\", \n      [\"Reactive Consumption\"] = \"Reaktiv forbruk\", \n      [\"Reactive Production\"] = \"Reaktiv produksjon\", \n      [\"Power Factor\"] = \"Effekt\", \n      [\"Signal strength\"] = \"Signalstyrke\", \n      [\"Timestamp\"] = \"Tid\"},} \n    translation = translation[language] -- Shorten the table to only the current translation\n  return translation\nend\n\n-- EOF  "},{"name":"readme","isMain":false,"isOpen":false,"content":"--[[ QuickApp Tibber Live readme\n\nThis QuickApp gets your energy consumption and production data from Tibber Live. \nThis QuickApp can be used in combination with the Tibber Monitor to get the Tibber Prices. \nBased on the Fibaro WebSockets/GraphQL demo by Peter Gebruers \n\nIf you use Tibber for your Energy Panel, you can use this Tibber Live QuickApp for your energy consumption and production combined with the Tibber Monitor QuickApp to provide the Energy Panel with the hourly prices. \n\n\nAvailable information: \n- power (Consumption at the moment (Watt))\n- maxPower (Peak consumption since midnight (Watt))\n- powerProduction (Net production (A-) at the moment (Watt))\n- maxPowerProduction (Max net production since midnight (Watt))\n- accumulatedConsumption (kWh consumed since midnight)\n- accumulatedProduction (net kWh produced since midnight)\n- accumulatedCost (Accumulated cost since midnight; requires active Tibber power deal)\n- currency (Currency of displayed cost; requires active Tibber power deal)\n- lastMeterConsumption (Last meter active import register state (kWh))\n- lastMeterProduction (Last meter active export register state (kWh))\n- voltagePhase1 (Voltage on phase 1) *\n- voltagePhase2 (Voltage on phase 2) *\n- voltagePhase3 (Voltage on phase 3) *\n- currentL1 (Current on L1) *\n- currentL2 (Current on L2) *\n- currentL3 (Current on L3) *\n- accumulatedConsumptionLastHour (kWh consumed since since last hour shift)\n- accumulatedProductionLastHour (net kWh produced since last hour shift)\n- accumulatedReward (Accumulated reward since midnight; requires active Tibber power deal)\n- minPower (Min consumption since midnight (Watt))\n- averagePower (Average consumption since midnight (Watt))\n- powerReactive (Reactive consumption (Q+) at the moment (kVAr)) *\n- powerProductionReactive (Net reactive production (Q-) at the moment (kVAr)) *\n- minPowerProduction (Min net production since midnight (Watt))\n- maxPowerProduction (Max net production since midnight (Watt))\n- powerFactor (Power factor (active power / apparent power)) *\n- signalStrength (Device signal strength (Pulse - dB; Watty - percent)) *\n- timestamp (Timestamp when usage occurred)\n\n* on Kaifa and Aidon meters the value is not part of every HAN data frame therefore the value is \"null\" at timestamps with second value other than 0, 10, 20, 30, 40, 50. There can be other deviations based on concrete meter firmware.) In this QuickApp \"null\" values are replaced by their previous values. \n\n\nMain device with positive or negative actual power consumption (with timestamp in the log text)\n\nChild devices are available for:\n- power (Actual consumption with maxPower in log text)\n- powerProduction (Actual production with maxPowerProduction in log text)\n- accumulatedConsumption (Todays consumption, also the child device for the Energy Panel)\n- accumulatedProduction (Todays production)\n- accumulatedCost (Todays cost)\n- accumulatedConsumptionLastHour (Consumed since since last hour shift)\n- accumulatedProductionLastHour (Produced since last hour shift)\n- lastMeterConsumption (Total consumption)\n- lastMeterProduction (Total production)\n- voltagePhase1\n- voltagePhase2\n- voltagePhase3\n- currentL1\n- currentL2\n- currentL3\n\n\nTo communicate with the API you need to acquire a OAuth access token and pass this along with every request passed to the server.\nA Personal Access Token give you access to your data and your data only. \nThis is ideal for DIY people that want to leverage the Tibber platform to extend the smartness of their home. \nSuch a token can be acquired here: https://developer.tibber.com\n\nWhen creating your access token or OAuth client you’ll be asked which scopes you want the access token to be associated with. \nThese scopes tells the API which data and operations the client is allowed to perform on the user’s behalf. \nThe scopes your app requires depend on the type of data it is trying to request. \nIf you for example need access to user information you add the USER scope. \nIf information about the user's homes is needed you add the appropriate HOME scopes.\nIf you have more than one home in your subscription, you need to fill in your home number the change between your homes. \n\nIf the Tibber server disconnects the webSocket, the QuickApp wil do a re-connect for the amount in the QuickApp variable reconnect. \nIf the re-connect fails for that amount, there will be a timeout for the seconds in the QuickApp variable timeout. \n\nUse this QuickApp at your own risk. You are responsible for ensuring that the information provided via this QuickApp do not contain errors. \nTibber is a registered trademark being the property of TIBBER. TIBBER reserves all rights to the registered trademarks.\nInformation which is published on TIBBER’s websites belongs to TIBBER or is used with the permission of the rights holder. \nMaking of copies, presentations, distribution, display or any other transfer of the information on the website to the public is, except for strictly private use, prohibited unless done with the consent of TIBBER. \nPublished material on dedicated TIBBER press websites, intended for public use, is exempt from the consent requirement.\nAlso see: https://tibber.com/en/legal-notice\n\nGuide Communicating with the Tibber API: https://developer.tibber.com/docs/guides/calling-api\nTibber API Explorer: https://developer.tibber.com/explorer\nTibber status: https://status.tibber.com\nTibber gitHub: https://github.com/tibber\nTibber SDK NET: https://github.com/tibber/Tibber.SDK.NET/tree/master/src/Tibber.Sdk\nFibaro webSocket manual: https://manuals.fibaro.com/knowledge-base-browse/hc3-quick-apps-websocket-client/\nFibaro Forum - Headers in webSocket: https://forum.fibaro.com/topic/60307-added-support-for-headers-in-websocket-connections-any-documentation\nWebSocket++ Documentation: https://docs.websocketpp.org\nGraphQL over WebSocket Protocol: https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md\nGraphQL query language: https://spec.graphql.org/June2018/#sec-Language\n\n\nTODO (maybe): \n- Wrap json.decode in pcall (?)\n- Change global variables to local variables (?)\n- Add the “Extra Cost” from the Tibber Monitor QA to the “Todays Cost” in Tibber Live\n- Show connection status in labels\n- Show update time child devices\n- Button to end webSocket session\n- A realtime device may get removed: it is recommended to check that home.features.realTimeConsumptionEnabled has a true value always before reconnecting. {viewer {home(id: \"96a14971-525a-4420-aae9-e5aedaa129ff\") {id features {realTimeConsumptionEnabled}}}}\n\n\nVersion 3.0 (8th March 2023)\n- Removed Tibber old Websocket code\n- Prepared, not enabled: Check home.features.realTimeConsumptionEnabled has a true value always before reconnecting\n- Prepared, not enabled: Added button to disconnect or re-connect the Tibber webSocket\n- Prepared: Added quickapp variable homeNr (most of the time 1) to be able to check the response realTimeConsumptionEnabled\n\n\nVersion 2.3 (beta 8th December 2022)\n- Improved the 60 seconds interval child devices update, it now never skips a beat\n- Added translation for English (en), Dutch (nl), Swedish (se), Norwegian (no)\n- Changed the json response for the debugLevel=4 Offline Simulation mode, the date/time format was wrong\n- Added random (jitter) reconnection handleDisconnected and handleError between 10 and 15 seconds\n- Added random (jitter) reconnection interval handleDisconnected and handleError plus between 1 and 10 seconds\n- Added exponential backoff (increasing delay) between each timeout. The increase is limited to 10 times the value in the quickapp reconnect variable. \n\nVersion 2.2 (20th November 2022)\n- Changed to new Tibber webSocket requirements, required from December 2022: \n  url = \"wss://api.tibber.com/v1-beta/gql/subscriptions\" -- Tibber Live (old) webSocket URL\n  changed to \n  url = \"wss://websocket-api.tibber.com/v1-beta/gql/subscriptions\" -- Tibber Live (new) webSocket URL\n\n  Subprotocol name graphql-transport-ws\n  headers[\"Sec-WebSocket-Protocol\"] = \"graphql-ws\" -- Old Tibber header protocol\n  changed to \n  headers[\"Sec-WebSocket-Protocol\"] = \"graphql-transport-ws\" -- New Tibber header protocol\n\n  Connection init message format structure and type (type is subscribe not start, token is passed as json object not string)\n  graphql_query.type = \"start\" -- Old Tibber graphql_query.type\n  changed to\n  graphql_query.type = \"subscribe\" -- New Tibber graphql_query.type\n\n  Returning message type (next, not data)\n  self.sock:addEventListener(\"dataReceived\", function(data) self:handleDataReceived(data) end) -- Old Tibber Returning message type\n  changed to\n  self.sock:addEventListener(\"dataReceived\", function(next) self:handleDataReceived(next) end) -- New Tibber Returning message type\n\n  Added new Tibber mandatory user-agent\n  headers[\"User-Agent\"] = \"Tibber_Live/2.2 Fibaro/HC3 Firmware/\" ..api.get(\"/settings/info\").softVersion\n\nVersion 2.1 (15th October 2022)\n- Child devices are now updated every (whole) minute to reduce CPU load\n- Replaced zero values for Voltage L1 L2 L3 with the previous value\n\nVersion 2.0 (5th August 2022)\n- Added two child devices, Hourly Consumption and Hourly Production\n- Added re-connect routine to handleError. If an Tibber error occurs, the QuickApp will try to re-connect. Thanks @JcBorgs for testing. \n- Improved routine to handle Tibber null value. Thanks @Darquan for testing. \n- Changed labels a bit to save some space\n- Changed \"volt\" and \"amp\" text in the labels\n- Changed kWh device types from com.fibaro.electricMeter to com.fibaro.energyMeter\n\nVersion 1.0 (19th June 2022)\n- Initial webSocket version Tibber Live\n- Thanks @JcBorgs for testing all beta versions and great suggestion to improve the quickapp\n- Based on the Fibaro WebSockets/GraphQL demo by Peter Gebruers \n\nVariables (mandatory and created automatically): \n- token = Authorization token (see the Tibber website: https://developer.tibber.com)\n- homeId = Tibber Home ID (see the Tibber website: https://developer.tibber.com)\n- homeNr = Tibber home (nodes) number if you have more than one home (default = 1)\n- language = Preferred language (default = en) (supported languages are English (en), Swedisch (se), Norwegian (no) and Dutch (nl))\n- reconnect = Amount of re-connects after disconnect from Tibber server (default = 10)\n- timeout = Pause after maximum amount of re-connects (default = 300 seconds)\n- debugLevel = Number (1=some, 2=few, 3=all, 4=Offline Simulation Mode, 5=Live Test Mode) (default = 1)\n\nFibaro Firmware minimal version 5.111.48 (beta)\n]]\n\n-- EOF "}]}